<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>News Tribune</title>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2099519216159666"
     crossorigin="anonymous"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header class="header">
        <div class="header-content">
            <div class="logo">NEWS TRIBUNE</div>
            <nav class="nav">
                <a href="#" onclick="navigateToHome()">Home</a>
                <a href="#" onclick="showCreate()" id="write-nav" style="display: none;">Write</a>
            </nav>
        </div>
    </header>

    <div id="home-page">
        <div class="container">
            <div id="main-content" class="main-content">
                <div class="loading">Loading articles...</div>
            </div>
            <div id="pagination" class="pagination"></div>
        </div>
    </div>

    <div id="create-page" class="create-page" style="display: none;">
        <div class="container">
            <h1>Write Article</h1>
            <form id="post-form">
                <div class="form-group">
                    <label for="title">Headline</label>
                    <input type="text" id="title" name="title" required>
                </div>
                <div class="form-group">
                    <label for="image">Featured Image (JPG/PNG)</label>
                    <input type="file" id="image" name="image" accept=".jpg,.jpeg,.png" style="padding: 0.5rem;">
                </div>
                <div class="form-group">
                    <label for="link_image">Or Image URL</label>
                    <input type="url" id="link_image" name="link_image" placeholder="https://example.com/image.jpg">
                </div>
                <div id="image-preview" class="image-preview"></div>
                <div class="form-group">
                    <label for="content">Article Content</label>
                    <textarea id="content" name="content" required></textarea>
                </div>
                <button type="submit" class="btn" id="submit-btn">Publish Article</button>
            </form>
        </div>
    </div>

    <div id="post-view" class="post-view" style="display: none;">
        <div class="container">
            <button class="btn back-btn" onclick="navigateToHome()">‚Üê Back</button>
            <h1 id="post-view-title"></h1>
            <div id="post-view-meta" class="meta"></div>
            <div id="post-view-content" class="content"></div>
        </div>
    </div>

    <footer class="footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <p>&copy; 2025 News Tribune. All rights reserved.</p>
                </div>
                <div class="footer-section">
                    <div class="social-links">
                        <a href="https://x.com/elonmusk" target="_blank">ùïè</a>
                        <a href="https://facebook.com/elonmusk" target="_blank">Facebook</a>
                        <a href="https://instagram.com/elonmusk" target="_blank">Instagram</a>
                        <a href="https://linkedin.com/in/elonmusk" target="_blank">LinkedIn</a>
                    </div>
                </div>
            </div>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <script>
        const POCKETBASE_URL = 'https://app.flashreport.rest';
        let currentPosts = [];
        let currentPage = 1;
        let totalPages = 1;
        const postsPerPage = 12;
        let fallbackMode = false;
        let fallbackPosts = [];
        
        // Router functionality
        class Router {
            constructor() {
                this.routes = new Map();
                this.currentRoute = null;
                
                // Handle browser navigation
                window.addEventListener('popstate', () => this.handleRoute());
                
                // Handle initial load
                this.handleRoute();
            }
            
            addRoute(pattern, handler) {
                this.routes.set(pattern, handler);
            }
            
            navigate(path, pushState = true) {
                if (pushState) {
                    history.pushState(null, '', path);
                }
                this.handleRoute();
            }
            
            handleRoute() {
                const path = window.location.pathname;
                const hash = window.location.hash;
                
                // Handle article routes: /{id} or /{id}#section
                const articleMatch = path.match(/^\/([a-zA-Z0-9_-]+)$/);
                if (articleMatch) {
                    const articleId = articleMatch[1];
                    this.showArticleById(articleId);
                    return;
                }
                
                // Default to home
                if (path === '/') {
                    showHome();
                    return;
                }
                
                // Fallback to home for unknown routes
                showHome();
            }
            
            async showArticleById(id) {
                // Wait for posts to load if not already loaded
                if (currentPosts.length === 0 && fallbackPosts.length === 0) {
                    await loadInitialData();
                }
                
                const posts = fallbackMode ? fallbackPosts : currentPosts;
                const post = posts.find(p => p.id === id);
                
                if (post) {
                    showPost(id, false); // Don't push state since we're handling routing
                } else {
                    // Redirect to home if post not found
                    this.navigate('/', true);
                }
            }
        }
        
        const router = new Router();
        
        document.addEventListener('DOMContentLoaded', function() {
            loadInitialData();
            document.getElementById('post-form').addEventListener('submit', handleSubmit);
            
            // Image preview handlers
            document.getElementById('image').addEventListener('change', handleFilePreview);
            document.getElementById('link_image').addEventListener('input', handleLinkPreview);
        });

        async function loadInitialData() {
            try {
                await loadPosts();
            } catch (error) {
                console.warn('PocketBase failed, switching to fallback mode:', error);
                await loadFallbackData();
            }
        }

        async function loadFallbackData() {
            try {
                const response = await fetch('./blog.md');
                if (!response.ok) throw new Error('Failed to load blog.md');
                
                const markdown = await response.text();
                fallbackPosts = parseBlogMarkdown(markdown);
                fallbackMode = true;
                
                // Hide write functionality in fallback mode
                document.getElementById('write-nav').style.display = 'none';
                
                renderFallbackPosts();
                showMessage('Running in offline mode - using local content', 'info');
            } catch (error) {
                console.error('Fallback data loading failed:', error);
                document.getElementById('main-content').innerHTML = 
                    '<div class="error">Failed to load content. Please check your connection.</div>';
            }
        }

        function parseBlogMarkdown(markdown) {
            const posts = [];
            const sections = markdown.split(/^---\s*$/gm);
            
            sections.forEach((section, index) => {
                if (section.trim()) {
                    const lines = section.trim().split('\n');
                    const frontMatter = {};
                    let contentStart = 0;
                    
                    // Parse front matter if exists
                    if (lines[0] === '---' || section.startsWith('---')) {
                        for (let i = 1; i < lines.length; i++) {
                            if (lines[i] === '---') {
                                contentStart = i + 1;
                                break;
                            }
                            const [key, ...valueParts] = lines[i].split(':');
                            if (key && valueParts.length) {
                                frontMatter[key.trim()] = valueParts.join(':').trim();
                            }
                        }
                    }
                    
                    const content = lines.slice(contentStart).join('\n').trim();
                    
                    if (content) {
                        const title = frontMatter.title || content.split('\n')[0].replace(/^#+\s*/, '') || `Article ${index + 1}`;
                        
                        posts.push({
                            id: frontMatter.id || `fallback-${index}`,
                            title: title,
                            post: content,
                            created: frontMatter.date || new Date().toISOString(),
                            likes: parseInt(frontMatter.likes) || 0,
                            image: frontMatter.image || null,
                            link_image: frontMatter.link_image || null,
                            collectionName: 'posts'
                        });
                    }
                }
            });
            
            return posts.sort((a, b) => new Date(b.created) - new Date(a.created));
        }

        function renderFallbackPosts() {
            currentPosts = fallbackPosts;
            totalPages = Math.ceil(fallbackPosts.length / postsPerPage);
            renderPosts();
            document.getElementById('pagination').innerHTML = ''; // Disable pagination for fallback
        }

        function navigateToHome() {
            router.navigate('/', true);
        }

        function handleFilePreview(e) {
            const file = e.target.files[0];
            const linkInput = document.getElementById('link_image');
            const preview = document.getElementById('image-preview');
            
            if (file) {
                linkInput.value = ''; // Clear link input
                const reader = new FileReader();
                reader.onload = function(e) {
                    preview.innerHTML = `<img src="${e.target.result}" alt="Preview" class="preview-image">`;
                };
                reader.readAsDataURL(file);
            } else {
                preview.innerHTML = '';
            }
        }

        function handleLinkPreview(e) {
            const url = e.target.value;
            const fileInput = document.getElementById('image');
            const preview = document.getElementById('image-preview');
            
            if (url) {
                fileInput.value = ''; // Clear file input
                if (isValidImageUrl(url)) {
                    preview.innerHTML = `<img src="${url}" alt="Preview" class="preview-image" onerror="this.parentElement.innerHTML='<p class=error-preview>Failed to load image</p>'">`;
                } else {
                    preview.innerHTML = '<p class="error-preview">Please enter a valid image URL</p>';
                }
            } else {
                preview.innerHTML = '';
            }
        }

        function isValidImageUrl(url) {
            return /\.(jpg|jpeg|png|gif|webp)(\?.*)?$/i.test(url) || url.includes('ichef.bbci.co.uk') || url.includes('images.');
        }

        function showHome() {
            document.getElementById('home-page').style.display = 'block';
            document.getElementById('create-page').style.display = 'none';
            document.getElementById('post-view').style.display = 'none';
        }

        function showCreate() {
            if (fallbackMode) {
                showMessage('Write functionality not available in offline mode', 'error');
                return;
            }
            document.getElementById('home-page').style.display = 'none';
            document.getElementById('create-page').style.display = 'block';
            document.getElementById('post-view').style.display = 'none';
        }

        async function checkForDuplicates(title, content) {
            if (fallbackMode) return false;
            
            try {
                const filter = encodeURIComponent(`title="${title}" || post="${content}"`);
                const response = await fetch(`${POCKETBASE_URL}/api/collections/posts/records?filter=${filter}`);
                const data = await response.json();
                return data.items && data.items.length > 0;
            } catch (error) {
                console.error('Duplicate check failed:', error);
                return false;
            }
        }

        async function removeDuplicates() {
            if (fallbackMode) {
                showMessage('Duplicate removal not available in offline mode', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${POCKETBASE_URL}/api/collections/posts/records?perPage=500`);
                const data = await response.json();
                const posts = data.items || [];
                
                const seen = new Map();
                const duplicates = [];
                
                posts.forEach(post => {
                    const key = `${post.title}_${post.post}`;
                    if (seen.has(key)) {
                        duplicates.push(post.id);
                    } else {
                        seen.set(key, post.id);
                    }
                });
                
                for (const id of duplicates) {
                    await fetch(`${POCKETBASE_URL}/api/collections/posts/records/${id}`, {
                        method: 'DELETE'
                    });
                }
                
                if (duplicates.length > 0) {
                    showMessage(`Removed ${duplicates.length} duplicate posts`, 'success');
                    loadPosts();
                }
            } catch (error) {
                console.error('Deduplication failed:', error);
            }
        }

        async function handleSubmit(e) {
            e.preventDefault();
            
            if (fallbackMode) {
                showMessage('Publishing not available in offline mode', 'error');
                return;
            }
            
            const submitBtn = document.getElementById('submit-btn');
            const originalText = submitBtn.textContent;
            submitBtn.disabled = true;
            submitBtn.textContent = 'Publishing...';
            
            const title = document.getElementById('title').value.trim();
            const content = document.getElementById('content').value.trim();
            const imageFile = document.getElementById('image').files[0];
            const linkImage = document.getElementById('link_image').value.trim();
            
            try {
                // Check for duplicates
                const isDuplicate = await checkForDuplicates(title, content);
                if (isDuplicate) {
                    showMessage('Article with same title or content already exists!', 'error');
                    return;
                }
                
                const formData = new FormData();
                formData.append('title', title);
                formData.append('post', content);
                formData.append('likes', '0');
                formData.append('link_image', linkImage);
                
                if (imageFile && !linkImage) {
                    formData.append('image', imageFile);
                }
                
                const response = await fetch(`${POCKETBASE_URL}/api/collections/posts/records`, {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    showMessage('Article published successfully!', 'success');
                    document.getElementById('post-form').reset();
                    document.getElementById('image-preview').innerHTML = '';
                    setTimeout(() => navigateToHome(), 1000);
                    loadPosts();
                } else {
                    const errorData = await response.json();
                    showMessage(`Failed to publish: ${errorData.message || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                showMessage('Error: ' + error.message, 'error');
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = originalText;
            }
        }

        async function loadPosts(page = 1) {
            if (fallbackMode) {
                renderFallbackPosts();
                return;
            }
            
            try {
                const response = await fetch(`${POCKETBASE_URL}/api/collections/posts/records?sort=-likes,-created&perPage=${postsPerPage}&page=${page}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                currentPosts = data.items || [];
                currentPage = page;
                totalPages = data.totalPages || 1;
                
                // Show write functionality since PocketBase is working
                document.getElementById('write-nav').style.display = 'inline';
                
                if (currentPosts.length === 0 && page === 1) {
                    document.getElementById('main-content').innerHTML = '<div class="loading">No articles yet.</div>';
                    document.getElementById('pagination').innerHTML = '';
                    return;
                }
                
                renderPosts();
                renderPagination();
            } catch (error) {
                console.error('PocketBase load failed:', error);
                await loadFallbackData();
            }
        }

        function getImageUrl(record) {
            if (record.link_image) {
                return record.link_image;
            }
            if (record.image && !fallbackMode) {
                return `${POCKETBASE_URL}/api/files/${record.collectionName}/${record.id}/${record.image}`;
            }
            if (record.image && fallbackMode) {
                return record.image; // In fallback mode, assume it's a direct URL
            }
            return null;
        }

        function renderPosts() {
            if (currentPage === 1 && !fallbackMode) {
                // Show featured layout for first page (PocketBase mode only)
                const featured = currentPosts[0];
                const regular = currentPosts.slice(1, 7);
                const trending = currentPosts.slice(7, 12);
                
                const featuredHTML = featured ? `
                    <div class="featured-post" onclick="showPost('${featured.id}')">
                        <h2>${escapeHtml(featured.title)}</h2>
                        <div class="meta">${formatDate(featured.created)} ‚Ä¢ ${featured.likes || 0} likes</div>
                        ${getImageUrl(featured) ? `<img src="${getImageUrl(featured)}" alt="${escapeHtml(featured.title)}" class="featured-image">` : ''}
                        <div class="excerpt">${escapeHtml(getExcerpt(featured.post, 200))}</div>
                        <div class="meta-bottom">
                            <button class="like-btn" onclick="event.stopPropagation(); likePost('${featured.id}', this)">
                                ‚ô• ${featured.likes || 0}
                            </button>
                        </div>
                    </div>
                ` : '';
                
                const regularHTML = regular.map(post => `
                    <div class="post-card" onclick="showPost('${post.id}')">
                        <h3>${escapeHtml(post.title)}</h3>
                        <div class="meta">${formatDate(post.created)}</div>
                        ${getImageUrl(post) ? `<img src="${getImageUrl(post)}" alt="${escapeHtml(post.title)}" class="post-image">` : ''}
                        <div class="excerpt">${escapeHtml(getExcerpt(post.post, 120))}</div>
                        <div class="meta">
                            <span></span>
                            <button class="like-btn" onclick="event.stopPropagation(); likePost('${post.id}', this)">
                                ‚ô• ${post.likes || 0}
                            </button>
                        </div>
                    </div>
                `).join('');
                
                const trendingHTML = trending.map(post => `
                    <div class="trending-post" onclick="showPost('${post.id}')">
                        <h4>${escapeHtml(post.title)}</h4>
                        <div style="font-size: 0.8rem; color: #999;">${post.likes || 0} likes</div>
                    </div>
                `).join('');
                
                document.getElementById('main-content').innerHTML = `
                    ${featuredHTML}
                    <div class="posts-grid">
                        ${regularHTML}
                    </div>
                    <div class="sidebar">
                        <h3>Trending</h3>
                        ${trendingHTML}
                        ${!fallbackMode ? '<button class="btn" onclick="removeDuplicates()" style="margin-top: 2rem; font-size: 0.9rem; padding: 0.5rem 1rem;">Clean Duplicates</button>' : ''}
                    </div>
                `;
            } else {
                // Show grid layout for other pages or fallback mode
                const postsHTML = currentPosts.map(post => `
                    <div class="post-card" onclick="showPost('${post.id}')">
                        <h3>${escapeHtml(post.title)}</h3>
                        <div class="meta">${formatDate(post.created)}</div>
                        ${getImageUrl(post) ? `<img src="${getImageUrl(post)}" alt="${escapeHtml(post.title)}" class="post-image">` : ''}
                        <div class="excerpt">${escapeHtml(getExcerpt(post.post, 120))}</div>
                        <div class="meta">
                            <span></span>
                            ${!fallbackMode ? `<button class="like-btn" onclick="event.stopPropagation(); likePost('${post.id}', this)">‚ô• ${post.likes || 0}</button>` : `<span>‚ô• ${post.likes || 0}</span>`}
                        </div>
                    </div>
                `).join('');
                
                document.getElementById('main-content').innerHTML = `
                    <div class="posts-grid-full">
                        ${postsHTML}
                    </div>
                `;
            }
        }

        function renderPagination() {
            if (totalPages <= 1 || fallbackMode) {
                document.getElementById('pagination').innerHTML = '';
                return;
            }

            let paginationHTML = '';
            
            // Previous button
            if (currentPage > 1) {
                paginationHTML += `<button class="pagination-btn" onclick="loadPosts(${currentPage - 1})">‚Üê Previous</button>`;
            }
            
            // Page numbers
            for (let i = Math.max(1, currentPage - 2); i <= Math.min(totalPages, currentPage + 2); i++) {
                if (i === currentPage) {
                    paginationHTML += `<button class="pagination-btn active">${i}</button>`;
                } else {
                    paginationHTML += `<button class="pagination-btn" onclick="loadPosts(${i})">${i}</button>`;
                }
            }
            
            // Next button
            if (currentPage < totalPages) {
                paginationHTML += `<button class="pagination-btn" onclick="loadPosts(${currentPage + 1})">Next ‚Üí</button>`;
            }
            
            document.getElementById('pagination').innerHTML = paginationHTML;
        }

        async function likePost(id, btn) {
            if (fallbackMode) {
                showMessage('Liking not available in offline mode', 'info');
                return;
            }
            
            try {
                const post = currentPosts.find(p => p.id === id);
                const newLikes = (post.likes || 0) + 1;
                
                const response = await fetch(`${POCKETBASE_URL}/api/collections/posts/records/${id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ likes: newLikes })
                });

                if (response.ok) {
                    post.likes = newLikes;
                    btn.innerHTML = `‚ô• ${newLikes}`;
                    btn.classList.add('liked');
                }
            } catch (error) {
                console.error('Like failed:', error);
            }
        }

        function showPost(id, updateUrl = true) {
            const posts = fallbackMode ? fallbackPosts : currentPosts;
            const post = posts.find(p => p.id === id);
            if (!post) return;
            
            // Update URL if requested
            if (updateUrl) {
                router.navigate(`/${id}`, true);
            }
            
            document.getElementById('home-page').style.display = 'none';
            document.getElementById('create-page').style.display = 'none';
            document.getElementById('post-view').style.display = 'block';
            
            document.getElementById('post-view-title').textContent = post.title;
            document.getElementById('post-view-meta').innerHTML = `
                ${formatDate(post.created)} ‚Ä¢ ${post.likes || 0} likes
            `;
            
            const imageHtml = getImageUrl(post) ? 
                `<img src="${getImageUrl(post)}" alt="${escapeHtml(post.title)}" class="post-view-image">` : '';
            
            document.getElementById('post-view-content').innerHTML = 
                imageHtml + marked.parse(post.post);
        }

        function getExcerpt(text, length) {
            return text.length > length ? text.substring(0, length) + '...' : text;
        }

        function formatDate(dateStr) {
            return new Date(dateStr).toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showMessage(message, type) {
            const existing = document.querySelector('.message');
            if (existing) existing.remove();
            
            const div = document.createElement('div');
            div.className = `message ${type}`;
            div.textContent = message;
            div.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 4px;
                color: white;
                z-index: 1000;
                font-weight: 500;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                background-color: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
            `;
            
            document.body.appendChild(div);
            setTimeout(() => div.remove(), 3000);
        }

        // Auto-refresh for PocketBase mode only
        setInterval(() => {
            if (!fallbackMode && document.getElementById('home-page').style.display !== 'none') {
                loadPosts(currentPage);
            }
        }, 60000);
    </script>
</body>
</html>
